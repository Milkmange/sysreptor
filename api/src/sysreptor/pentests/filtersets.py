import datetime

from django.db.models import Q
from django.utils.dateparse import parse_datetime
from django_filters import rest_framework as filters

from sysreptor.pentests.models import PentestProject
from sysreptor.pentests.models.archive import ArchivedProject


class MultiValueFilter(filters.Filter):
    def __init__(self, negate: bool = False, *args, **kwargs):
        self.negate = negate
        super().__init__(*args, **kwargs)

    def _get_params(self):
        request = getattr(self.parent, 'request', None)
        if request:
            for param_name, filter_obj in self.parent.filters.items():
                if filter_obj == self:
                    if values := request.GET.getlist(param_name, []):
                        yield from values


class MultiValueCharFilter(MultiValueFilter, filters.CharFilter):
    def filter(self, qs, value):
        if value in ([], (), {}, None, ''):
            return qs
        if not getattr(self.parent, 'request', None):
            return super().filter(qs, value)

        q_objects = Q()
        for val in self._get_params():
            # For each value, create a Q object
            if self.lookup_expr in ('iexact', 'icontains', 'iregex', 'contains'):
                kwargs = {f"{self.field_name}__{self.lookup_expr}": val}
            elif self.lookup_expr == 'array_contains':
                kwargs = {f"{self.field_name}__contains": [val]}
            else:
                kwargs = {self.field_name: val}

            # Create a negated Q object if negate is True
            q_obj = ~Q(**kwargs) if self.negate else Q(**kwargs)
            # Combine with existing conditions using the appropriate operator
            q_objects = q_objects & q_obj if self.negate else q_objects | q_obj

        return qs.filter(q_objects)


class MultiValueTimeRangeFilter(MultiValueFilter, filters.CharFilter):
    def filter(self, qs, value):
        if value in ([], (), {}, None, ''):
            return qs
        if not getattr(self.parent, 'request', None):
            return super().filter(qs, value)

        q_objects = Q()
        for val in self._get_params():
            after, before = val.split('|')
            # Handle empty values
            if after and after != 'null':
                after_date = parse_datetime(after)
                q_obj_after = Q(**{f"{self.field_name}__gte": after_date})
            else:
                q_obj_after = Q()

            if before and before != 'null':
                before_date = parse_datetime(before) + datetime.timedelta(days=1)  # Add one day to include the end date
                q_obj_before = Q(**{f"{self.field_name}__lte": before_date})
            else:
                q_obj_before = Q()

            # Combine the time range conditions
            q_obj = q_obj_after & q_obj_before

            # Combine with existing conditions using the appropriate operator
            q_objects = q_objects & ~Q(q_obj) if self.negate else q_objects | q_obj

        return qs.filter(q_objects)


class PentestProjectFilterSet(filters.FilterSet):
    tag = MultiValueCharFilter(field_name='tags', lookup_expr='array_contains')
    not_tag = MultiValueCharFilter(field_name='tags', lookup_expr='array_contains', negate=True)
    timerange = MultiValueTimeRangeFilter(field_name='created', lookup_expr='range')
    not_timerange = MultiValueTimeRangeFilter(field_name='created', lookup_expr='range', negate=True)
    language = MultiValueCharFilter(field_name='language', lookup_expr='exact')
    not_language = MultiValueCharFilter(field_name='language', lookup_expr='exact', negate=True)

    class Meta:
        model = PentestProject
        fields = ["readonly"]


class ArchivedProjectFilterSet(filters.FilterSet):
    tag = MultiValueCharFilter(field_name='tags', lookup_expr='array_contains')
    not_tag = MultiValueCharFilter(field_name='tags', lookup_expr='array_contains', negate=True)
    timerange = MultiValueTimeRangeFilter(field_name='created', lookup_expr='range')
    not_timerange = MultiValueTimeRangeFilter(field_name='created', lookup_expr='range', negate=True)

    class Meta:
        model = ArchivedProject
        fields = []
